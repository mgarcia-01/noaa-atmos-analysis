---
title: "Research Analysis for NOAA Weather"
output:
  html_notebook: default
  html_document: default
  md_document:
    variant: markdown_github
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Storm Research Analysis {.tabset .tabset-fade .tabset-pills}

### Main Report Section

##### Synopsis 
This report utilizes NOAA storm weather data to explain weather patterns. The weather in research are disastrous conditions, and the attributes of the weather. The analysis will also deliver results on the events that directly may have resulted from the unusual weather. 

##### Data Processing

The data was fetched from NOAA (see Citation for url). The source to pull process and retain the data can be see in the code below. The code for data tables and graphcs is provided within the R Chunks. There are a few values within my statements that are inline R chunks. The RMD file will show which use inlince calculations.

```{r Data Processing, include=TRUE, echo=TRUE}
### Week 1 Project ###
#library(data.table)
webURL <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
destURL <- file.path(getwd(),paste("repdata_data_StormData.csv",".bz2",sep = ""))
download.file(webURL,destfile = destURL)

#unzip(destURL)
#localFileURL <- file.path(getwd(),paste("repdata_data_StormData",".csv",sep = ""))
repdata <- read.csv(destURL)
```

##### Summary

Summary of Each Variable.

```{r summary, include = TRUE, echo=FALSE}
#as.table(summary(repdata))

## rmarkdown::paged_table()
```

##### Events most harmful to population health

```{r event types,include =  TRUE, echo = TRUE}
eventFreq <- aggregate(repdata$EVTYPE, list(repdata$EVTYPE), length)
names(eventFreq) <- c("EVTYPE","Qty")
eventFatal <- aggregate(repdata$FATALITIES, list(repdata$EVTYPE), sum)
names(eventFatal) <- c("EVTYPE","FATALITIES")
eventsInjur <- aggregate(repdata$INJURIES, list(repdata$EVTYPE), sum)
names(eventsInjur) <- c("EVTYPE","INJURIES")
#a <- eventFreq[order(eventFreq$Qty, decreasing = TRUE),]
eventDamag <- merge(eventFreq,eventFatal, by.x = "EVTYPE", all = TRUE)
eventDamag <- merge(eventDamag, eventsInjur, by.x = "EVTYPE", all = TRUE)
eventDamag <- eventDamag[order(eventDamag$"Qty", decreasing = TRUE),]
eventDamag
#plot(eventFreq$EVTYPE,eventFreq$Qty,type ="h")
```
This table shows the event types ordered by frequency. This depicts that the most frequent types `r eventDamag[1,1]` at `r eventDamag[1,2]` and `r eventDamag[2,1]` at `r eventDamag[2,2]` are not the most fatal or the most injuring.  


```{r damageqty, include = TRUE, echo = TRUE}
dm <- head(eventDamag[order(eventDamag$Qty, decreasing = TRUE),],10)
dm$Qty <- as.numeric(dm$Qty)
dm$EVTYPE <- factor(dm$EVTYPE)
#plot(pl$EVTYPE,(pl$TOTLDMG/1000), type = "h", xlab = "EVTYPE", ylab = "Total Damage Amount")

library(ggplot2)
ggplot(dm, aes(x=reorder(EVTYPE, -Qty), y=format(Qty, scientific = FALSE), group=1)) + geom_bar(stat = "identity", fill = "#0099FF")+ 
            theme(axis.text.x = element_text(angle = 45, hjust = 1)
                               ,axis.title.x = element_text(face="bold", size=12)
                               ,legend.position="none")+
                                    labs(x="Event Type",y="Event Frequency") 
```
This table displayes the top ten events that are most frequent. `r head(dm$EVTYPE,1)` is the event that occurs the most at `r format(head(dm$Qty,1), scientific = FALSE)` number of events. `r dm[10,1]` is the least top frequent occuring event coming at `r format(dm[10,2], scientific = FALSE)` number of events.




#####  Events have the greatest economic consequences


```{r event histogram,include =  TRUE, echo = TRUE}
#a <- head(eventDamag[order(eventDamag$"Qty", decreasing = TRUE),],5)
#plot(a$EVTYPE, as.numeric(a$Qty/1000), type = "h")
#   “K” for thousands, “M” for millions, and “B” for billions
#PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP
      # totaldmg doesnt work since the exp is different for prop and crop
##totalDmg <- aggregate((repdata$PROPDMG+repdata$CROPDMG), list(repdata$EVTYPE,repdata$PROPDMGEXP), sum)
##colnames(totalDmg) <- c("EVTYPE","TOTALEXP","TOTALDMG")
bil <- 1000000000
mil <- 1000000
thous <- 1000

repDataConv <- repdata
propDmg <- aggregate((ifelse(repdata$PROPDMGEXP == "B",repdata$PROPDMG*bil
                             ,ifelse(repdata$PROPDMGEXP == "M",repdata$PROPDMG*mil
                                     , ifelse(repdata$PROPDMGEXP == "K"
                                              ,repdata$PROPDMG*thous
                                              ,0
                                              )
                                     )
                          )
                      )
                             , list(repdata$EVTYPE
                                    #,repdata$PROPDMGEXP
                                    ), sum)
#colnames(propDmg) <- c("EVTYPE","EXP","PROPDMG")
colnames(propDmg) <- c("EVTYPE","PROPDMG")

cropDmg <- aggregate((ifelse(repdata$CROPDMGEXP == "B",repdata$CROPDMG*bil
                             ,ifelse(repdata$CROPDMGEXP == "M",repdata$CROPDMG*mil
                                     , ifelse(repdata$CROPDMGEXP == "K",repdata$CROPDMG*thous
                                              ,0
                                              )
                                     )
                          )
                      ), list(repdata$EVTYPE
                              #,repdata$CROPDMGEXP
                              ), sum)
#colnames(cropDmg) <- c("EVTYPE","EXP","CROPDMG")
colnames(cropDmg) <- c("EVTYPE","CROPDMG")

eventDamagProp <- merge(eventDamag, propDmg,by.x = "EVTYPE", all = TRUE)
eventDmgPrp <- merge(eventDamagProp, cropDmg,by.x = "EVTYPE", all = FALSE)
                                                  #c("EVTYPE","EXP")
eventDmgPrp$TOTLDMG <- (eventDmgPrp$PROPDMG + eventDmgPrp$CROPDMG)

# this is the Millions
 #a <- eventDmgPrp[which(eventDmgPrp$EXP == "B"),]
# head(a[order(a$TOTLDMG, decreasing = TRUE),],10)
 #head(eventDmgPrp[order(eventDmgPrp$TOTLDMG, decreasing = TRUE),],10)
eventDmgPrp$PROPDMG <- round(eventDmgPrp$PROPDMG/1000,1)
eventDmgPrp$CROPDMG <- round(eventDmgPrp$CROPDMG/1000,1)
eventDmgPrp$TOTLDMG <- round(eventDmgPrp$TOTLDMG/1000,1)
eventDmgPrp[order(eventDmgPrp$TOTLDMG, decreasing = TRUE),]
```
This table is sorted by the total property damage cost from most to least and represented in thousands ('000). The values were converted to full dollar amount based on the EXP value.



```{r damageplot, include= TRUE, echo = TRUE}
pl <- head(eventDmgPrp[order(eventDmgPrp$TOTLDMG, decreasing = TRUE),],10)
pl$TOTLDMG <- as.numeric(pl$TOTLDMG)
pl$EVTYPE <- factor(pl$EVTYPE)
#plot(pl$EVTYPE,(pl$TOTLDMG/1000), type = "h", xlab = "EVTYPE", ylab = "Total Damage Amount")

library(ggplot2)
ggplot(pl, aes(x=reorder(EVTYPE, -TOTLDMG), y=format(TOTLDMG, scientific = FALSE), group=1)) + geom_bar(stat = "identity", fill = "#0099FF")+ 
            theme(axis.text.x = element_text(angle = 45, hjust = 1)
                               ,axis.title.x = element_text(face="bold", size=12)
                               ,legend.position="none")+
                                    labs(x="Event Type",y="Damage Amount (000's)") 
                                    
# plot(activityWkend$interval, activityWkend$avgSteps, type = "l",xlab = "interval", ylab = "WkEnd Avg Steps")
```
This chart shows the top 10 most economically damaging events, from most to least. The Flood is the most costly and the Ice Storm is the least.








### Source Citation and Resource:
    NATIONAL WEATHER SERVICE INSTRUCTION  10-1605 
    AUGUST 17, 2007 
    Operations and Services 
    Performance, NWSPD 10-16
    STORM DATA PREPARATION


    Storm Data Documentation: https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf
    FAQ: https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2FNCDC%20Storm%20Events-FAQ%20Page.pdf
    

    
### License and Copyright Notice
    ### Default License and Copyright Notice
    Self published Research Analysis for NOAA Weather
    Copyright (C) 2017 Michael Garcia. All Rights Reserved.
    Unless otherwise noted, default copyright is excercised
    and exclusive rights of the author. 
    https://www.copyright.gov/title17/
    
    Source code from other authors, and only that source code,
    retain their respective License. If any conflict overall;
    the most permissive, copy-left license overrides project License.
    Fees and permits by author, if any, still apply.
    
    Licensing, pricing, permission inquiries, token to use source code 
      contact mgar_datascience at protonmail.com.
    
    To submit contributions required by permissive copy-left license,
      contact mgar_datascience at protonmail.com for token to 
      source repository.

    This program is distributed  WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
    PURPOSE.  
    
##
